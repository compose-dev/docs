---
sidebar_position: 1
hide_title: true
title: Component | Table
description: Render a table.
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import IFrame from "../../../src/iframe";
import { ParameterTemplate, Parameter, CustomCodeBlock } from "../../../src/components";
import CodeBlock from "@theme/CodeBlock";

# Component | Table

Display and interact with tabular data. Start with a single function call, and scale to an enterprise-grade feature set when you need it. Tables offer:

- **Actions** to add interactivity to each row.
- **Customizable columns** that can be pinned, hidden, and formatted for a variety of data types.
- **Built-in data controls** to search, sort, and filter data, along with [views](#views) to save configurations of these controls.
- **Pagination and virtualization** to efficiently scale to millions of rows.

<IFrame type="components-input-table" heightPx={675} />

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```js
    const customers = [{ name: "Apple", tier: "Enterprise", arr: 150000, onboarded: true }, /* ... */]

    ui.table(
        "customers-table",
        customers,
        { 
            actions: [
                { 
                    label: "Details", 
                    onClick: (row) => page.modal(() => ui.json(row), { title: "Customer Details" }) 
                }
            ],
            columns: [
                "name",
                { key: "tier", format: "tag" },
                { key: "arr", label: "ARR", format: "currency" },
                "onboarded"
            ],
            views: [
                {
                    label: "Highest ARR",
                    description: "Sort by ARR (decreasing)",
                    sortBy: [{ key: "arr", direction: "desc" }],
                    isDefault: true,
                },
                {
                    label: "Enterprise Customers",
                    description: "Filter to show only enterprise customers",
                    filterBy: {
                        key: "tier",
                        operator: "hasAny",
                        value: ["Enterprise"],
                    },
                },
            ]
        }
    )
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    customers = [
        { "name": "Apple", "tier": "Enterprise", "arr": 150000, "onboarded": True }
        # ...
    ]

    ui.table(
        "customers-table",
        customers,
        actions=[
            { 
                "label": "Details", 
                "on_click": lambda row: page.modal(lambda: ui.json(row), title="Customer Details") 
            }
        ],
        columns=[
            "name",
            { "key": "tier", "format": "tag" },
            { "key": "arr", "label": "ARR", "format": "currency" },
            "onboarded"
        ],
        views=[
            {
                "label": "Highest ARR",
                "description": "Sort by ARR (decreasing)",
                "sort_by": [{"key": "arr", "direction": "desc"}],
                "is_default": True,
            },
            {
                "label": "Enterprise Customers",
                "description": "Filter to show only enterprise customers"
                "filter_by": {
                    "key": "tier",
                    "operator": "has_any",
                    "value": ["Enterprise"],
                }
            }
        ]
    )
    ```
    </TabItem>
</Tabs>

## Row actions

Actions are a powerful construct that allows you to add row-level interactivity to your table. Tables can have an unlimited number of actions, rendered either as buttons or nested inside a dropdown menu.

Actions are often used as a foundation to create robust [multipage apps](/guides/multipage-apps).

Each action's callback will receive the row and index as arguments.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```js
    ui.table("table-key",
    [ /* list of users */ ],
    { 
        actions: [
            { 
                label: "Details",
                onClick: (row) => page.link("user-details", { params: { id: row.id } }) 
            },
            { 
                label: "Delete",
                onClick: (row) => deleteUser(row.id),
                appearance: "danger"
            },
            {
                label: "View",
                onClick: (row, idx) => page.modal(() => ui.json(row)),
                surface: true // Render as button instead of inside dropdown (or vice-versa if false).
            }
        ]
    })
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    ui.table(
        "table-key",
        [<list-of-users>],
        actions=[
            {
                "label": "Details",
                "on_click": lambda row: page.link("user-details", params={"id": row["id"]})
            },
            {
                "label": "Delete",
                "on_click": lambda row: delete_user(row["id"]),
                "appearance": "danger"
            },
            {
                "label": "View",
                "on_click": lambda row, idx: page.modal(lambda: ui.json(row)),
                "surface": True # Render as button instead of inside dropdown (or vice-versa if False).
            }
        ]
    )
    ```
    </TabItem>
</Tabs>

<IFrame type="components-input-table-actions" heightPx={350} />

### Action object properties

<Parameter
    name="label"
    required={true}
    type="string"
    description="The user-facing label to display for the action."
/>

<Parameter
    name={lang => lang === "js" ? "onClick" : "on_click"}
    required={true}
    type={lang => lang === "js" ? "(row: TableRow, idx: number) => void" : "Callable[[TableRow, int], None]"}
    description="Callback to execute when the action is clicked. The row and index will be passed as arguments."
/>

<Parameter
    name={() => "appearance"}
    required={false}
    type="literal"
    description={
        <>
            <p>The appearance of the action. Defaults to <code>outline</code>. Options:</p>
            <ul>
                <li><code>"primary"</code></li>
                <li><code>"outline"</code></li>
                <li><code>"warning"</code></li>
                <li><code>"danger"</code></li>
            </ul>
        </>
    }
/>

<Parameter
    name={() => "surface"}
    required={false}
    type="boolean"
    description={lang =>
        <>
        <p>
            Set to <code>{lang === "js" ? "true" : "True"}</code> to render the action as a button. Set to <code>{lang === "js" ? "false" : "False"}</code> to render the action inside a dropdown.
        </p>
        <p>
            By default, if the table has only one action, it will render as a button. If there are multiple actions, they'll render inside a dropdown.
        </p>
        </>
    }
/>

## Columns

By default, Compose infers which columns to show (and how to render them) from your data. To take control, pass a columns array: either simple key strings or full column-definition objects.

### Selecting & ordering

Choose which fields to show, and in what order, by listing their property keys.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```js
    const users = [
        { name: "John", age: 30, createdAt: new Date("2021-01-01"), isActive: true },
        { name: "Jane", age: 25, createdAt: new Date("2021-01-02"), isActive: false },
    ]

    // highlight-start
    // Show only name -> age -> isActive
    ui.table("table-key", users, { columns: ["name", "age", "isActive"] })
    // highlight-end
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    users = [
        {"name": "John", "age": 30, "created_at": datetime(2021, 1, 1), "is_active": True},
        {"name": "Jane", "age": 25, "created_at": datetime(2021, 1, 2), "is_active": False},
    ]

    # highlight-start
    # Show only name -> age -> is_active
    ui.table("table-key", users, columns=["name", "age", "is_active"])
    # highlight-end
    ```
    </TabItem>

</Tabs>

### Formatting

Compose will infer column labels and data types from your data. Override this behavior by passing objects that allows you to more granularly control each column:

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">
    - `label`: specify the header text.
    - `width`: specify a custom width for the column.
    - `format`: choose from a variety of built-in types like `date`, `currency`, `tag`, `json`, etc.
    - `tagColors`: map values to pill colors when using the `tag` format. 
    </TabItem>
    <TabItem value="python" label="Python">
    - `label`: specify the header text.
    - `width`: specify a custom width for the column.
    - `format`: choose from a variety of built-in types like `date`, `currency`, `tag`, `json`, etc.
    - `tag_colors`: map values to pill colors when using the `tag` format. 
    </TabItem>
</Tabs>

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```js
    const users = [
        { name: "John", createdAt: new Date("2021-01-01"), isActive: true, tier: "Enterprise" },
        { name: "Jane", createdAt: new Date("2021-01-02"), isActive: false, tier: "Basic" },
    ]

    ui.table("table-key", users, {
        columns: [
            "name",
            { key: "createdAt", format: "date", width: "150px" },
            { key: "isActive", label: "Status", format: "boolean" },
            { key: "tier", format: "tag", tagColors: { "blue": ["Enterprise", "Pro"], "green": "Basic" } }
        ]
    })
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    users = [
        {"name": "John", "created_at": datetime(2021, 1, 1), "is_active": True, "tier": "Enterprise"},
        {"name": "Jane", "created_at": datetime(2021, 1, 2), "is_active": False, "tier": "Basic"},
    ]

    ui.table(
        "table-key",
        users,
        columns=[
            "name",
            {"key": "created_at", "format": "date", "width": "150px"},
            {"key": "is_active", "label": "Status", "format": "boolean"},
            {"key": "tier", "format": "tag", "tag_colors": { "blue": ["Enterprise", "Pro"], "green": "Basic" }}
        ]
    )
    ```
    </TabItem>
</Tabs>

### Visibility & pinning

While end-users can toggle column visibility and pinning via the table's toolbar, you can also control the initial settings:

- `hidden`: hide a column.
- `pinned`: pin a column to the left or right of the table.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```js
    ui.table("table-key", users, {
        columns: [
            { key: "name", pinned: "left" },
            { key: "createdAt", hidden: true },
            "isActive",
            "tier"
        ]
    })
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    ui.table(
        "table-key",
        users,
        columns=[
            { "key": "name", "pinned": "left" },
            { "key": "created_at", "hidden": True },
            "isActive",
            "tier"
        ]
    )
    ```
    </TabItem>
</Tabs>

### Column object properties

<Parameter
    name="key"
    required={true}
    type="string"
    description="Specify which property of the data object should be displayed in that column."
/>

<Parameter
    name={() => "label"}
    required={false}
    type="string"
    description={<p>Specify a custom label for the column. If not provided, the label will be inferred from the <code>key</code></p>}
/>

<Parameter
    name={() => "width"}
    required={false}
    type="string"
    description={<p>Specify a custom width for the column (e.g. <code>"150px"</code> or <code>"3rem"</code>). If not provided, the width will be inferred from the content.</p>}
/>

<Parameter
    name={() => "format"}
    required={false}
    type="literal"
    description={lang =>
        <>
            <p>
                The data type of the column. Specifying this allows Compose to render the column in a more user-friendly format, and sort and filter correctly. If not provided, the format will be inferred from the data.
            </p>
            <p>Options:</p>
            <ul>
                <li>
                    <code>"date"</code>: Render a date in a human-friendly format (e.g. <code>Oct 10, 2000</code>). {lang === "js" ? <>Expects a <code>Date</code> object or ISO string.</> : <>Expects a <code>datetime</code> object or ISO string.</>}
                </li>
                <li>
                    <code>"datetime"</code>: Render a datetime in a human-friendly format (e.g. <code>Oct 10, 2000, 11:14 AM</code>). {lang === "js" ? <>Expects a <code>Date</code> object or ISO string.</> : <>Expects a <code>datetime</code> object or ISO string.</>}
                </li>
                <li>
                    <code>"number"</code>: Render a number in a human-friendly format (e.g. <code>1,234</code>).
                </li>
                <li>
                    <code>"currency"</code>: Render a number in a currency format (e.g. <code>$1,234.56</code>).
                </li>
                <li>
                    <code>"boolean"</code>: Render a boolean in a human-friendly format (e.g. `✅` or `❌`). Will perform a truthiness check on non-boolean values.
                </li>
                <li>
                    <code>"tag"</code>: Render values (or lists of values) as <span className="colored-pill colored-pill-purple">colored</span> <span className="colored-pill colored-pill-green">pills</span>. Useful for enum-type data. You can pass a <code>{lang === "js" ? "tagColors" : "tag_colors"}</code> property to specify the colors of the tags. If not provided, Compose will randomly assign colors to each value.
                </li>
                <li>
                    <code>"json"</code>: Render JSON objects and arrays as formatted code blocks.
                </li>
                <li>
                    <code>"string"</code>: Stringify the value and render as is. Use when you don't want any special formatting.
                </li>
            </ul>
        </>
    }
/>

<Parameter
    name={(lang) => lang === "js" ? "tagColors" : "tag_colors"}
    required={false}
    type={(lang) => lang === "js" ? "Record<string, string | string[]>"  : "dict[str, str | list[str]]"}
    description={lang =>
        <>
            <p>
                Map tag colors to column values when using <code>format: "tag"</code>. If this property is not provided, Compose will randomly assign colors to each value.
            </p>
            <p>
                Colors can be mapped to single values or arrays of values. If a value isn't mapped to a color, it will use the <code>_default</code> color if specified, or be automatically assigned a color.
            </p>
            <p>Available colors: <span className="colored-pill colored-pill-red">red</span>, <span className="colored-pill colored-pill-orange">orange</span>, <span className="colored-pill colored-pill-yellow">yellow</span>, <span className="colored-pill colored-pill-green">green</span>, <span className="colored-pill colored-pill-blue">blue</span>, <span className="colored-pill colored-pill-purple">purple</span>, <span className="colored-pill colored-pill-pink">pink</span>, <span className="colored-pill colored-pill-gray">gray</span>, <span className="colored-pill colored-pill-brown">brown</span>.</p>
            <p>Example:</p>
            <CustomCodeBlock.TagColors lang={lang} />
            <p>
                Compose tags support <code>{lang === "js" ? "string" : "str"}</code>, <code>{lang === "js" ? "number" : "int"}</code>, {lang === "js" ? "" : <> <code>float</code>,</>} and <code>{lang === "js" ? "boolean" : "bool"}</code> values, or lists of these values. Any other value will be rendered as plain text.
            </p>
        </>
    }
    version="0.23.0"
/>

<Parameter
    name={() => "hidden"}
    required={false}
    type="boolean"
    description="Whether to initially hide the column from the table. This can always be toggled by the user via the table's toolbar. By default, all columns are visible."
/>

<Parameter
    name={() => "pinned"}
    required={false}
    type="literal"
    description={lang =>
        <>
            <p>Whether to pin the column to the left or right of the table. Options:</p>
            <ul>
                <li>
                    <code>"left"</code>: Pin the column to the left of the table.
                </li>
                <li>
                    <code>"right"</code>: Pin the column to the right of the table.
                </li>
            </ul>
            <p>
                By default, columns are not pinned.
            </p>
        </>
    }
/>

<Parameter
    name={() => "overflow"}
    required={false}
    type="literal"
    description={lang =>
        <>
            <p>Whether to truncate the cell content if it overflows the column width. In most cases, you should use the table's <code>overflow</code> property instead. This property will override the table-wide setting for this column. Options:</p>
            <ul>
                <li>
                    <code>"clip"</code>: Clip the cell content if it overflows.
                </li>
                <li>
                    <code>"dynamic"</code>: Expand the cell's height to fit the content.
                </li>
                <li>
                    <code>"ellipsis"</code>: Show an ellipsis (<code>...</code>) when the cell content overflows.
                </li>
            </ul>
            <p>
                The default behavior is to use the table-wide overflow setting, which itself defaults to <code>"ellipsis"</code>.
            </p>
        </>
    }
/>

## Data controls

Every table includes built-in data controls that enable users to search, sort, and filter data.

### Views

Views let your users switch between preset configurations of data and presentation controls. They enable complex workflows, while taking just a few minutes to setup.

As an example, the following table includes three views, each of which serves a unique purpose.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    const customers = db.selectCompanies();

    page.add(() => ui.table("customers-table", customers, {
        columns: [
            "name",
            "createdAt",
            "onboardingComplete",
            {
                key: "plan",
                format: "tag",
                tagColors: {
                    "blue": "Enterprise",
                    "green": "Pro",
                    "red": "Basic"
                }
            },
            {
                key: "arr",
                label: "ARR",
                format: "currency"
            },
            {
                key: "featureFlags",
                format: "json",
                hidden: true
            }, 
        ],
        // highlight-start
        views: [
            // View 1: Enterprise customers, sorted by ARR.
            {
                label: "Enterprise Customers",
                description: "Enterprise customers, sorted by ARR.",
                filterBy: {
                    key: "plan",
                    operator: "hasAny",
                    value: ["Enterprise"]
                },
                sortBy: [
                    {
                        key: "arr",
                        direction: "desc"
                    }
                ]
            },
            // View 2: Feature flags, with table rows expanded to show the flags object.
            {
                label: "Feature Flags",
                description: "View customer feature flags",
                columns: {
                    featureFlags: {
                        hidden: false,
                        pinned: "right"
                    },
                    arr: {
                        hidden: true
                    }
                },
                overflow: "dynamic"
            },
            // View 3: Customers still in onboarding, sorted by oldest to newest.
            {
                label: "Onboarding Customers",
                description: "Customers still in onboarding, sorted by oldest to newest.",
                filterBy: {
                    key: "onboarding",
                    operator: "is",
                    value: false
                },
                sortBy: [
                    {
                        key: "createdAt",
                        direction: "asc"
                    }
                ]
            }
        ]
        // highlight-end
    }))
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    customers = db.select_companies();

    page.add(lambda: ui.table(
        "customers-table",
        customers,
        columns=[
            "name",
            "created_at",
            "onboarding_complete",
            {
                "key": "plan",
                "format": "tag",
                "tag_colors": {
                    "blue": "Enterprise",
                    "green": "Pro",
                    "red": "Basic"
                }
            },
            {
                "key": "arr",
                "label": "ARR",
                "format": "currency"
            },
            {
                "key": "feature_flags",
                "format": "json",
                "hidden": True
            }, 
        ],
        # highlight-start
        views=[
            # View 1: Enterprise customers, sorted by ARR.
            {
                "label": "Enterprise Customers",
                "description": "Enterprise customers, sorted by ARR.",
                "filter_by": {
                    "key": "plan",
                    "operator": "has_any",
                    "value": ["Enterprise"]
                },
                "sort_by": [
                    {
                        "key": "arr",
                        "direction": "desc"
                    }
                ]
            },
            # View 2: Feature flags, with table rows expanded to show the flags object.
            {
                "label": "Feature Flags",
                "description": "View customer feature flags",
                "columns": {
                    "feature_flags": {
                        "hidden": False,
                        "pinned": "right"
                    },
                    "arr": {
                        "hidden": True
                    }
                },
                "overflow": "dynamic"
            },
            # View 3: Customers still in onboarding, sorted by oldest to newest.
            {
                "label": "Onboarding Customers",
                "description": "Customers still in onboarding, sorted by oldest to newest.",
                "filter_by": {
                    "key": "onboarding",
                    "operator": "is",
                    "value": False
                },
                "sort_by": [
                    {
                        "key": "created_at",
                        "direction": "asc"
                    }
                ]
            }
        ]
        # highlight-end
    ))
    ```
    </TabItem>
</Tabs>

### Filtering

Compose tables support complex filtering operations via a combination of filter rules and filter groups.

- **Filter rule**: A single filter that's applied to a column. For example, "Revenue column greater than 1000".
- **Filter group**: A collection of filter rules and groups that are applied together using a logical operator. For example, "Revenue column greater than 1000 AND Country column is United States".

Disable column filtering by setting the table's `filterable` property to `false`.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    const customers = db.selectCompanies();

    page.add(() => ui.table("customers-table", customers, {
        columns: [
            "name",
            "createdAt",
            "onboardingComplete",
            { key: "plan", format: "tag" },
            { key: "arr", format: "currency" },
        ],
        views: [
            {
                label: "Enterprise Customers",
                // highlight-start
                // Example 1: Apply a single filter rule.
                filterBy: {
                    key: "plan",
                    operator: "hasAny",
                    value: ["Enterprise"]
                },
                // highlight-end
            },
            {
                label: "Urgent Customers",
                // highlight-start
                // Example 2: A complex nested filter group.
                filterBy: {
                    logicalOperator: "and",
                    filters: [
                        {
                            key: "plan",
                            operator: "hasAny",
                            value: ["Enterprise"]
                        },
                        {
                            logicalOperator: "or",
                            filters: [
                                {
                                    key: "arr",
                                    operator: "greaterThan",
                                    value: 1000
                                },
                                {
                                    key: "onboardingComplete",
                                    operator: "is",
                                    value: false
                                }
                            ]
                        }
                    ]
                }
                // highlight-end
            },
        ]
    }))
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    customers = db.select_companies();

    page.add(lambda: ui.table(
        "customers-table",
        customers,
        columns=[
            "name",
            "created_at",
            "onboarding_complete",
            { "key": "plan", "format": "tag" },
            { "key": "arr", "format": "currency" },
        ],
        views=[
            {
                "label": "Enterprise Customers",
                # highlight-start
                # Example 1: Apply a single filter rule.
                "filter_by": {
                    "key": "plan",
                    "operator": "has_any",
                    "value": ["Enterprise"]
                },
                # highlight-end
            },
            {
                "label": "Urgent Customers",
                # highlight-start
                # Example 2: A complex nested filter group.
                "filter_by": {
                    "logical_operator": "and",
                    "filters": [
                        {
                            "key": "plan",
                            "operator": "has_any",
                            "value": ["Enterprise"]
                        },
                        {
                            "logical_operator": "or",
                            "filters": [
                                {
                                    "key": "arr",
                                    "operator": "greater_than",
                                    "value": 1000
                                },
                                {
                                    "key": "onboarding_complete",
                                    "operator": "is",
                                    "value": False
                                }
                            ]
                        }
                    ]
                },
                # highlight-end
            },
        ]
    ))
    ```
    </TabItem>
</Tabs>

#### Filtering API reference

A complete type definition of the column filter property is provided below for reference.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    type ColumnFilterLogicOperator = "and" | "or";

    // Note: Each column format supports a subset of these operators. More info below.
    type ColumnFilterOperator = 
        | "is"
        | "isNot"
        | "includes"
        | "notIncludes"
        | "greaterThan"
        | "greaterThanOrEqual"
        | "lessThan"
        | "lessThanOrEqual"
        | "isEmpty"
        | "isNotEmpty"
        | "hasAny"
        | "notHasAny"
        | "hasAll"
        | "notHasAll";

    interface TableColumnFilterRule<TData extends TableDataRow[]> {
        key: StringOnlyKeys<TData[number]>;
        operator: ColumnFilterOperator;
        value: any;
    }

    interface TableColumnFilterGroup<TData extends TableDataRow[]> {
        logicOperator: ColumnFilterLogicOperator;
        filters: NonNullable<TableColumnFilterModel<TData>>[];
    }

    type TableColumnFilterModel<TData extends TableDataRow[]> =
        | TableColumnFilterRule<TData>
        | TableColumnFilterGroup<TData>
        | null;
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    ColumnFilterLogicOperator = Literal["and", "or"]

    # Note: Each column format supports a subset of these operators. More info below.
    ColumnFilterOperator = Literal[
        "is",
        "is_not",
        "includes",
        "not_includes",
        "greater_than",
        "greater_than_or_equal",
        "less_than",
        "less_than_or_equal",
        "is_empty",
        "is_not_empty",
        "has_any",
        "not_has_any",
        "has_all",
        "not_has_all",
    ]

    class TableColumnFilterGroup(TypedDict):
        logic_operator: ColumnFilterLogicOperator
        filters: Sequence[Union[TableColumnFilterRule, TableColumnFilterGroup]]

    class TableColumnFilterRule(TypedDict):
        operator: ColumnFilterOperator
        value: Any
        key: str

    TableColumnFilterModel = Union[TableColumnFilterRule, TableColumnFilterGroup, None]
    ```
    </TabItem>
</Tabs>

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">

| Column Format | Supported Operators |
| ------------- | ------------------- |
| `string`, `json` | `is`, `isNot`, `includes`, `notIncludes`, `isEmpty`, `isNotEmpty` |
| `number`, `currency`, `date`, `datetime` | `greaterThan`, `greaterThanOrEqual`, `lessThan`, `lessThanOrEqual`, `isEmpty`, `isNotEmpty` |
| `boolean` | `is`, `isNot`, `isEmpty`, `isNotEmpty` |
| `tag` | `is`, `isNot`, `hasAny`, `notHasAny`, `hasAll`, `notHasAll`, `isEmpty`, `isNotEmpty` |

    </TabItem>
    <TabItem value="python" label="Python">

| Column Format | Supported Operators |
| ------------- | ------------------- |
| `string`, `json` | `is`, `is_not`, `includes`, `not_includes`, `is_empty`, `is_not_empty` |
| `number`, `currency`, `date`, `datetime` | `greater_than`, `greater_than_or_equal`, `less_than`, `less_than_or_equal`, `is_empty`, `is_not_empty` |
| `boolean` | `is`, `is_not`, `is_empty`, `is_not_empty` |
| `tag` | `is`, `is_not`, `has_any`, `not_has_any`, `has_all`, `not_has_all`, `is_empty`, `is_not_empty` |

    </TabItem>
</Tabs>

### Searching

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">
    Compose tables support global search via a search bar at the top of the table. A default query can be specified via the `searchQuery` property.
    </TabItem>
    <TabItem value="python" label="Python">
    Compose tables support global search via a search bar at the top of the table. A default query can be specified via the `search_query` property.
    </TabItem>
</Tabs>

Disable global search by setting the table's `searchable` property to `false`.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    const customers = db.selectCompanies();

    page.add(() => ui.table("customers-table", customers, {
        columns: [
            "name",
            "createdAt",
            "notes"
        ],
        // highlight-start
        views: [
            {
                label: "Urgent customers",
                description: "Search the table for any row containing the word 'urgent'.",
                searchQuery: "urgent",
            },
        ]
        // highlight-end
    }))
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    customers = db.select_companies();

    page.add(lambda: ui.table(
        "customers-table",
        customers,
        columns=[
            "name",
            "created_at",
            "notes"
        ],
        # highlight-start
        views=[
            {
                "label": "Urgent note",
                "description": "Search the table for any row containing the word 'urgent'.",
                "search_query": "urgent"
        ]
        # highlight-end
    ))
    ```
    </TabItem>
</Tabs>

#### Searching API reference

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    // Either a string or null if no search is being performed.
    type TableSearchQuery = string | null;
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    # Either a string or None if no search is being performed.
    TableSearchQuery = str | None
    ```
    </TabItem>
</Tabs>

### Sorting

Compose tables support multi-column sorting via an ordered list of sort rules.

Disable sorting by setting the table's `sortable` property to `false`, or limit to single-column sorting by setting the property to `"single"`.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    const customers = db.selectCompanies();

    page.add(() => ui.table("customers-table", customers, {
        columns: [
            "name",
            "createdAt",
            "tier",
            "seatCount"
        ],
        // highlight-start
        views: [
            {
                label: "Largest to smallest customers",
                description: "Sort the table by seat count, then by name.",
                sortBy: [
                    { key: "seatCount", direction: "desc" },
                    { key: "name", direction: "asc" }
                ]
            },
        ]
        // highlight-end
    }))
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    customers = db.select_companies();

    page.add(lambda: ui.table(
        "customers-table",
        customers,
        columns=[
            "name",
            "created_at",
            "tier"
        ],
        # highlight-start
        views=[
            {
                "label": "Largest to smallest customers",
                "description": "Sort the table by seat count, then by name.",
                "sort_by": [
                    { "key": "seat_count", "direction": "desc" },
                    { "key": "name", "direction": "asc" }
                ]
            },
        ]
        # highlight-end
    ))
    ```
    </TabItem>
</Tabs>

#### Sorting API reference

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    interface TableColumnSortRule<TData extends TableDataRow[]> {
        key: StringOnlyKeys<TData[number]>; // The column to sort by.
        direction: "asc" | "desc"; // The direction to sort by.
    }

    // An ordered list of column sort rules.
    type TableColumnSortModel<TData extends TableDataRow[]> = TableColumnSortRule<TData>[];
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    class TableColumnSortRule(TypedDict):
        key: str # The column to sort by.
        direction: Literal["asc", "desc"] # The direction to sort by.

    # An ordered list of column sort rules.
    TableColumnSortModel = List[TableColumnSortRule]
    ```
    </TabItem>
</Tabs>

### View object properties

<Parameter
    name="label"
    required={true}
    type="string"
    description="The user-facing label for the view."
/>

<Parameter
    name={() => "description"}
    required={false}
    type="string"
    description={<p>A brief description of what the view does.</p>}
/>

<Parameter
    name={lang => lang === "js" ? "isDefault" : "is_default"}
    required={false}
    type="boolean"
    description={lang => <p>Whether to apply this view by default when the table loads. Defaults to <code>{lang === "js" ? "false" : "False"}</code>. Only one view can be the default.</p>}
/>

<Parameter
    name={lang => lang === "js" ? "filterBy" : "filter_by"}
    required={false}
    type={lang => lang === "js" ? "TableColumnFilterModel" : "TableColumnFilterModel"}
    description={lang =>
        <>
            <p>
                Filter the table according to the provided filter model. Learn more in the <a href="#filtering">filtering</a> section.
            </p>
        </>
    }
/>

<Parameter
    name={lang => lang === "js" ? "sortBy" : "sort_by"}
    required={false}
    type={lang => lang === "js" ? "TableColumnSortModel" : "TableColumnSortModel"}
    description={() =>
        <>
            <p>
                Sort the table according to the provided sort model.
            </p>
            <p>
                Should be an ordered list of sort rules. Each rule is an object with a <code>key</code> field that maps to a column key, and a <code>direction</code> field that is either <code>"asc"</code> or <code>"desc"</code>.
            </p>
            <p>
                Learn more in the <a href="#sorting">sorting</a> section.
            </p>
        </>
    }
/>

<Parameter
    name={lang => lang === "js" ? "searchQuery" : "search_query"}
    required={false}
    type="string"
    description={() =>
        <>
            <p>
                A global search query to filter the table by. Learn more in the <a href="#searching">searching</a> section.
            </p>
        </>
    }
/>

<Parameter
    name={() => "density"}
    required={false}
    type="literal"
    description={() =>
        <>
            <p>
                Override the default density of the table rows for this view. Options:
            </p>
            <ul>
                <li>
                    <code>"compact"</code>: 32px row height.
                </li>
                <li>
                    <code>"standard"</code>: 40px row height.
                </li>
                <li>
                    <code>"comfortable"</code>: 48px row height.
                </li>
            </ul>
        </>
    }
    idSuffix='1'
/>

<Parameter
    name={() => "overflow"}
    required={false}
    type="literal"
    description={() =>
        <>
            <p>
                Override the default overflow behavior of the table cells for this view. Options:
            </p>
            <ul>
                <li>
                    <code>"clip"</code>: Clip the cell content if it overflows.
                </li>
                <li>
                    <code>"dynamic"</code>: Expand the cell's height to fit the content.
                </li>
                <li>
                    <code>"ellipsis"</code>: Show an ellipsis (<code>...</code>) when the cell content overflows.
                </li>
            </ul>
        </>
    }
/>

<Parameter
    name={() => "columns"}
    required={false}
    type="literal"
    description={(lang) =>
        <>
            <p>
                Override the default <code>pinned</code> and <code>hidden</code> properties of specified table columns for this view. For example:
            </p>
            {lang === "js" ? <CodeBlock language="js">
{`{
    name: { pinned: "left" },
    uuid: { hidden: false }
}`}
            </CodeBlock> : <CodeBlock language="python">
{`{
    "name": { "pinned": "left" },
    "uuid": { "hidden": False }
}`}
            </CodeBlock>}
            <p>
                The structure is an object where the keys are the column keys, and the values are an object with the properties to override. Currently, the supported properties are <code>pinned</code> and <code>hidden</code>.
            </p>
        </>
    }
/>

## Pagination

### Automatic Pagination

Tables with more than 2500 rows are automatically paginated without any additional configuration on your end, enabling Compose to remain performant at scale.

Auto-pagination disables searching, filtering, and sorting since the browser only has a paginated subset of the data. You can re-enable these features by manually paginating the table, which enables you to manage these features on your own server-side via a simple callback function.

### Manual Pagination

For very large datasets, you should manually paginate tables by passing a getter function to the `data` parameter. Manual pagination enables you to:
- fetch data from your data store as needed, instead of having to load everything into memory at once.
- manage search, filtering, and sorting using your own custom logic.
- scale endlessly (millions of rows) without performance degradation.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    import { TablePageChangeParams, TablePageChangeResponse } from "@composehq/sdk"

    async function onPageChange(params: TablePageChangeParams): TablePageChangeResponse {
        const {
            offset,
            pageSize,
            refreshTotalRecords,
            prevTotalRecords,
            searchQuery, // optional to handle search
            sortBy, // optional to handle sorting
            filterBy, // optional to handle filtering
        } = params;

        const totalRecords = refreshTotalRecords || prevTotalRecords === null
            ? await postgres.countUsers(searchQuery, filterBy)
            : prevTotalRecords;

        const pageOfUsers = await postgres.getUsers(offset, pageSize, searchQuery, sortBy, filterBy);

        return {
            data: pageOfUsers,
            totalRecords,
        };
    }

    page.add(() => ui.table("users-table", onPageChange))
    ```


    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    import compose_sdk as c

    def on_page_change(args: c.TablePageChangeArgs) -> c.TablePageChangeResponse:
        # Unpack arguments
        offset = args["offset"]
        page_size = args["page_size"]
        refresh_total_records = args["refresh_total_records"]
        prev_total_records = args["prev_total_records"]
        search_query = args["search_query"] # optional to handle search
        sort_by = args["sort_by"] # optional to handle sorting
        filter_by = args["filter_by"] # optional to handle filtering

        # Only recalculate total records when needed
        total_records = (
            postgres.count_users(search_query, filter_by, sort_by)
            if refresh_total_records or prev_total_records is None
            else prev_total_records
        )

        page_of_users = postgres.get_users(offset, page_size, search_query, sort_by, filter_by)

        return {"data": page_of_users, "total_records": total_records}

    page.add(lambda: ui.table("users-table", on_page_change))
    ```
    </TabItem>
</Tabs>

#### Pagination type definitions

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    // Passed to the onPageChange callback as a single object.
    interface TablePageChangeParams<TData extends TableDataRow[]> {
        // The number of rows to skip.
        offset: number;
        // The number of rows to return. You can return less than this if there
        // aren't enough rows to fill the page (e.g. the last page).
        pageSize: number;
        // The search query to filter the rows by. Will be null if no search
        // is being performed.
        searchQuery: string | null;
        // The sort model to sort the rows by. Will be an empty list if no sorting
        // is being performed.
        sortBy: TableColumnSortModel<TData>;
        // The filter model to filter the rows by. Will be null if no filtering
        // is being performed.
        filterBy: TableColumnFilterModel<TData> | null;
        // Whether to refresh the total number of records. Provided so that you
        // only recalculate the total record count when needed.
        refreshTotalRecords: boolean;
        // The previous total number of records. If refreshTotalRecords is false,
        // simply return the previous total number of records.
        prevTotalRecords: number | null;
    }


    // Expected return type of the onPageChange callback.
    interface TablePageChangeResponse {
        // The data for the current page. Should be an array of objects.
        data: TableData;
        // The total number of records. This is used to calculate the number
        // of pages.
        totalRecords: number;
    }
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    # Passed to the on_page_change callback as a single positional argument.
    class TablePageChangeArgs(TypedDict):
        # The number of rows to skip.
        offset: int
        # The number of rows to return. You can return less than this if there
        # aren't enough rows to fill the page (e.g. the last page).
        page_size: int
        # The search query to filter the rows by. Will be None if no search
        # is being performed.
        search_query: str | None
        # The sort model to sort the rows by. Will be an empty list if no sorting
        # is being performed.
        sort_by: TableColumnSortModel
        # The filter model to filter the rows by. Will be None if no filtering
        # is being performed.
        filter_by: TableColumnFilterModel
        # Whether to refresh the total number of records. Provided so that you
        # only recalculate the total record count when needed.
        refresh_total_records: bool
        # The previous total number of records. If refresh_total_records is false,
        # simply return the previous total number of records.
        prev_total_records: int | None


    # The expected return type of the on_page_change callback.
    class TablePageChangeResponse(TypedDict):
        # The data for the current page. Should be a list of dictionaries.
        data: TableData
        # The total number of records. This is used to calculate the number
        # of pages.
        total_records: int
    ```
    </TabItem>
</Tabs>

Learn more about the format of the data controls:
- [Filtering API reference](#filtering-api-reference)
- [Searching API reference](#searching-api-reference)
- [Sorting API reference](#sorting-api-reference)

### Handle data controls

By default, data controls (search, filtering, sorting) are disabled for paginated tables.

It's up to you to whether you want to handle some or all of these controls in your page change callback. If not handling, you can simply ignore those parameters in your page change callback.

For controls you choose to handle, you'll need to explicitly enable the control in the table component.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    ui.table(
        "users-table",
        onPageChange,
        // highlight-start
        {
            searchable: true,
            sortable: true,
            filterable: true
        }
        // highlight-end
    )
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    ui.table(
        "users-table",
        on_page_change,
        # highlight-start
        searchable=True,
        sortable=True,
        filterable=True
        # highlight-end
    )
    ```
    </TabItem>
</Tabs>

### Handle row selection

While Compose normally passes a list of full table rows to selection callback functions, it's not possible to do this for paginated tables since only a paginated subset of the data is available at any time.

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">
    To enable row selections for paginated tables, you'll need to pass a `selectionReturnType: "id"` property to the table. When this is enabled, Compose will pass a list of row IDs to any callbacks instead of the rows themselves.

    The row ID should be a unique, stable identifier for each row (such as a `uuid`). It is specified via the `primaryKey` property. If not provided, Compose will default to using the row index (though this is not recommended since the row index is not stable).
    </TabItem>
    <TabItem value="python" label="Python">
    To enable row selections for paginated tables, you'll need to pass a `selection_return_type: "id"` property to the table. When this is enabled, Compose will pass a list of row IDs to any callbacks instead of the rows themselves.

    The row ID should be a unique, stable identifier for each row (such as a `uuid`). It is specified via the `primary_key` property. If not provided, Compose will default to using the row index (though this is not recommended since the row index is not stable).
    </TabItem>
</Tabs>

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    ui.table(
        "users-table",
        onPageChange,
        // highlight-start
        {
            selectionReturnType: "id",
            primaryKey: "uuid", // maps to the `uuid` field in the table data
            onChange: (selectedRows) => {
                console.log(selectedRows) // [uuid1, uuid2, uuid3, ...]
            }
        }
        // highlight-end
    )
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    ui.table(
        "users-table",
        on_page_change,
        # highlight-start
        selection_return_type="id",
        primary_key="uuid", # maps to the `uuid` field in the table data
        on_change=lambda selected_rows: print(selected_rows) # [uuid1, uuid2, uuid3, ...]
        # highlight-end
    )
    ```
    </TabItem>
</Tabs>

## Row selection

Compose tables support row selection out of the box. To enable row selection:

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">
    1. Specify a `primaryKey` that maps to a unique, stable identifier for each row (such as a `uuid`). (If not provided, Compose will default to using the row index, though this is not recommended since the row index is not stable.)
    2. Pass an `onChange` callback that will be called when the user selects/deselects rows.
    </TabItem>
    <TabItem value="python" label="Python">
    1. Specify a `primary_key` that maps to a unique, stable identifier for each row (such as a `uuid`). (If not provided, Compose will default to using the row index, though this is not recommended since the row index is not stable.)
    2. Pass an `on_change` callback that will be called when the user selects/deselects rows.
    </TabItem>
</Tabs>

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    ui.table(
        "users-table",
        users,
        // highlight-start
        {
            primaryKey: "uuid", // maps to the `uuid` field in the table data
            onChange: (selectedUsers) => {
                console.log(selectedUsers) // [user1, user2, user3, ...]
            }
        }
        // highlight-end
    )
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    ui.table(
        "users-table",
        users,
        # highlight-start
        primary_key="uuid", # maps to the `uuid` field in the table data
        on_change=lambda selected_users: print(selected_users) # [user1, user2, user3, ...]
        # highlight-end
    )
    ```
    </TabItem>
</Tabs>

### Advanced patterns

#### Row selection actions

A common use case is to take action on a set of selected rows. To do this, it's easy to combine row selections with buttons to quickly build out a UI.

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    let selectedUsers: User[] = [];

    page.add(() => ui.table(
        "users-table",
        users,
        {
            primaryKey: "uuid",
            onChange: (newSelectedUsers) => {
                selectedUsers = newSelectedUsers;
                page.update();
            }
            initialSelectedRows: selectedUsers
        }
    ))
    
    // Show a refund button if there are selected users
    page.add(() => ui.cond(selectedUsers.length > 0, {
        true: ui.button("Refund selected users", onClick: () => {
            selectedUsers.forEach((user) => refundUser(user.uuid));
            selectedUsers = [];
            page.update(); // update table to clear row selections
        })
    }))
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    selected_users: list[User] = []

    def on_change_selections(new_selected_users: list[User]) -> None:
        selected_users = new_selected_users
        page.update()

    page.add(lambda: ui.table(
        "users-table",
        users,
        primary_key="uuid",
        on_change=on_change_selections,
        initial_selected_rows=selected_users
    ))

    def on_click_refund_users() -> None:
        [refund_user(user["uuid"]) for user in selected_users]
        selected_users = []
        page.update() # update table to clear row selections

    # Show a refund button if there are selected users
    page.add(lambda: ui.cond(
        selected_users.length > 0,
        true=ui.button(
            "Refund selected users",
            on_click=on_click_refund_users
        )
    ))
    ```
    </TabItem>
</Tabs>

#### Usage in forms

To use tables in a form, simply:

<Tabs groupId="sdkLanguage" className="hide_tabs">
    <TabItem value="node" label="TypeScript / JavaScript">
    1. Include the table component inside the form.
    2. Pass `selectable: true` to the table component, which will enable row selections without the need to pass an `onChange` callback.
    </TabItem>
    <TabItem value="python" label="Python">
    1. Include the table component inside the form.
    2. Pass `selectable=True` to the table component, which will enable row selections without the need to pass an `on_change` callback.
    </TabItem>
</Tabs>

Once integrated into a form, row selections will automatically be included as a key in the form's submission payload.

Furthermore, just like other form inputs, table components include the following properties that are useful when used in forms:

- `validate`: Perform field-level validation on the row selections to validate the form.
- `required`: Whether at least one row must be selected to submit the form.

#### Paginated tables

Paginated tables require a slightly different configuration to enable row selections. Read more in the [paginated row selection guide](#handle-row-selection).

## Look & feel

Tables include two powerful properties that make it easy to customize their look and feel.

### Density

The `density` property can be used to control the overall density of table rows.

| Density | Is Default | Row Height | Font Size | Best For |
| ------- | ---------- | ---------- | --------- | -------- |
| `compact` | ❌ | 32px | 12px | Dense data, many columns |
| `standard` | ✅ | 40px | 14px | General use |
| `comfortable` | ❌ | 48px | 16px | Sparse data, few columns |

### Cell overflow

The `overflow` property controls how table cells handle content that exceeds the cell's width.

| Overflow | Is Default | Behavior |
| -------- | ---------- | -------- |
| `ellipsis` | ✅ | The content will be truncated with an ellipsis. |
| `clip` | ❌ | The content will be clipped to the cell. |
| `dynamic` | ❌ | The cell height will grow to fit the content. |

## API reference

### Function signature

<Tabs groupId="sdkLanguage">
    <TabItem value="node" label="TypeScript / JavaScript">
    ```ts
    type TableRow = {
        [key: string]: string | number | boolean | Date | null | undefined | object
    }

    ui.table<T extends TableRow>(
        id: string,
        data: T[] | TablePageChangeCallback<T>,
        properties?: Partial<{
            // General
            label: string,
            description: string,

            // Features
            columns: TableColumn[],
            actions: TableAction<T>[],
            views: TableView[],

            // Row selection
            selectable: boolean,
            primaryKey: string,
            required: boolean 
            initialSelectedRows: number[],
            validate: (values: T[]) => string | void,
            onChange: (values: T[]) => void,
            selectionReturnType: "full" | "id",
            minSelections: number,
            maxSelections: number,

            // Data controls
            searchable: boolean,
            sortable: boolean,
            filterable: boolean,
            paginate: boolean,

            // Style
            density: "compact" | "standard" | "comfortable",
            overflow: "ellipsis" | "clip" | "dynamic",
            style: Style,
        }>
    )
    ```
    </TabItem>
    <TabItem value="python" label="Python">
    ```python
    TableDataRow = Dict[str, Any]
    TableData = List[TableDataRow]

    ui.table(
        id: str,
        data: TableData | TablePageChangeCallback,
        *,
        # General
        label: str | None = None,
        description: str | None = None,
        
        # Features
        columns: TableColumns | None = None,
        actions: list[TableAction] | None = None,
        views: list[TableView] | None = None,

        # Row selection
        selectable: bool = False,
        primary_key: str | None = None,
        required: bool = True,
        initial_selected_rows: list[int] | None = None,
        validate: Callable[[TableData], str | None] | None = None,
        on_change: Callable[[TableData], None] | None = None,
        selection_return_type: Literal["full", "id"] = "full",
        min_selections: int = 0,
        max_selections: int = 1000000000,

        # Data controls
        searchable: bool = True, # defaults false for paginated tables
        sortable: bool = True, # defaults false for paginated tables
        filterable: bool = True, # defaults false for paginated tables
        paginate: bool = False,

        # Style
        density: Literal["compact", "standard", "comfortable"] = "standard",
        overflow: Literal["ellipsis", "clip", "dynamic"] = "ellipsis",
        style: Style | None = None,
    )
    ```
    </TabItem>
</Tabs>

### Parameters

<ParameterTemplate.Id />

<Parameter
    name="data"
    required={true}
    type={(lang) => lang === "js" ? "TableRow[] | TablePageChangeCallback" : "TableData | TablePageChangeCallback"}
    description={(lang) =>
        <>
            <p>The data to be displayed in the table. Each item in the {lang === "js" ? "array" : "list"} represents a row in the table, and should be {lang === "js" ? "an object" : "a dictionary"} where the keys correspond to column names and the values are the cell contents.</p>
            <p>Compose supports most data types including strings, numbers, booleans, dates, and objects.</p>
            <p>For larger datasets, you can paginate the table server-side by passing a function that returns one page of data at a time. See the <a href="#pagination">pagination</a> section for more details.</p>
        </>
    }
/>

<ParameterTemplate.Label
    componentName="table"
/>

<ParameterTemplate.Description
    componentName="table"
/>

<Parameter
    name="columns"
    required={false}
    type={(lang) => lang === "js" ? "TableColumn[]" : "list[TableColumn]"}
    description={lang => <p>Control how columns are rendered in the table. If not provided, Compose will default to using the keys from the first row of data, then do it's best to infer human readable column names, data types, etc. See the <a href="#columns">columns</a> section for more details.</p>}
/>

<Parameter
    name="actions"
    required={false}
    type={(lang) => lang === "js" ? "TableAction[]" : "list[TableAction]"}
    description={lang => <p>Add row-level action buttons that execute custom functions when clicked. See the <a href="#row-actions">row actions</a> section for more details.</p>}
/>

<Parameter
    name="views"
    required={false}
    type={(lang) => lang === "js" ? "TableView[]" : "list[TableView]"}
    description={lang => <p>Add custom views that allow users to switch between preset configurations of data and presentation controls, such as sorts, filters, pinned columns, etc. See the <a href="#views">views</a> section for more details.</p>}
/>

<Parameter
    name="selectable"
    required={false}
    type="boolean"
    description={lang => <p>Whether to show the row selection column. Defaults to <code>{lang === "js" ? "false" : "False"}</code>, or true if an <code>{lang === "js" ? "onChange" : "on_change"}</code> callback is provided.</p>}
/>

<Parameter
    name={lang => lang === "js" ? "properties.primaryKey" : "primary_key"}
    required={false}
    type="string"
    description={lang => <p>A key that maps to a field in the table data. The field should be a stable, unique identifier for each row (such as a <code>uuid</code>). Setting this property enables proper row selection tracking. If not provided, the row index will be used (not recommended).</p>}
/>

<ParameterTemplate.Required
    parameter="required"
    componentName="table"
    hookName={lang => lang === "js" ? "onChange" : "on_change"}
    description={lang => <p>Validate that the table has at least one row selected before submitting the form it's part of or calling it's <code>{lang === "js" ? "onChange" : "on_change"}</code> hook. Defaults to <code>{lang === "js" ? "true" : "True"}</code>.</p>}
/>

<Parameter
    name={(lang) => lang === "js" ? "properties.initialSelectedRows" : "initial_selected_rows"}
    required={false}
    type={(lang) => lang === "js" ? "number[]" : "list[int]"}
    description={lang => <p>A list of row indices to pre-select when the table is first rendered. Defaults to <code>{lang === "js" ? "[]" : "[]"}</code> (empty list).</p>}
/>

<ParameterTemplate.ValidateInput
    componentName="table"
    description={lang => <p>Validate the selected rows before submitting. If the function returns a string, it will be displayed as an error message.</p>}
    hookInputArgument={lang => lang === "js" ? "selectedRows: TableRow[]" : "TableData"}
/>

<ParameterTemplate.OnChange
    componentName="table"
    description={lang => <p>A callback function that is called when the table selection(s) change. The callback is passed the list of currently selected rows.</p>}
    hookInputArgument={lang => lang === "js" ? "selectedRows: TableRow[]" : "TableData"}
/>

<Parameter
    name={lang => lang === "js" ? "properties.selectionReturnType" : "selection_return_type"}
    required={false}
    type="literal"
    version="0.27.0"
    description={(lang) => <>
        <p>Options:</p>
        <ul>
            <li><code>"full"</code>: Return the full row data to callback functions when the user selects rows.</li>
            <li><code>"id"</code>: Return the row ids to callback functions when the user selects rows.</li>
        </ul>
        <p>By default, this property is set to <code>"full"</code>.</p>
        <p>Paginated tables only support row selections by id. If you're using a paginated table, you'll need to set this property to <code>"id"</code> to enable row selections. If not, Compose will disable row selections for the paginated table.</p>
    </>}
/>

<Parameter
    name={lang => lang === "js" ? "properties.minSelections" : "min_selections"}
    required={false}
    type="int"
    description={(lang) => <p>Validate that the user has selected at least some number of rows. Defaults to 0.</p>}
/>

<Parameter
    name={lang => lang === "js" ? "properties.maxSelections" : "max_selections"}
    required={false}
    type="int"
    description={(lang) => <p>Validate that the user has selected at most some number of rows. Defaults to 1000000000.</p>}
/>

<Parameter
    name="searchable"
    required={false}
    type="boolean"
    version="0.24.0"
    description={(lang) => <>
        <p>Whether to show the search input. Defaults to <code>{lang === "js" ? "true" : "True"}</code> for normal tables, <code>{lang === "js" ? "false" : "False"}</code> for paginated tables.</p>
    </>}
/>

<Parameter
    name="sortable"
    required={false}
    type="boolean"
    version="0.27.0"
    description={(lang) => <>
        <p>Whether to allow sorting. Defaults to <code>{lang === "js" ? "true" : "True"}</code> for normal tables, <code>{lang === "js" ? "false" : "False"}</code> for paginated tables.</p>
        <p>Options:</p>
        <ul>
            <li><code>{lang === "js" ? "true" : "True"}</code>: Allow multi-column sorting.</li>
            <li><code>"single"</code>: Allow single-column sorting.</li>
            <li><code>{lang === "js" ? "false" : "False"}</code>: Disable sorting.</li>
        </ul>
    </>}
/>

<Parameter
    name="filterable"
    required={false}
    type="boolean"
    version="0.27.0"
    description={(lang) => <>
        <p>Whether to allow column filtering. Defaults to <code>{lang === "js" ? "true" : "True"}</code> for normal tables, <code>{lang === "js" ? "false" : "False"}</code> for paginated tables.</p>
    </>}
/>


<Parameter
    name="paginate"
    required={false}
    type="boolean"
    version="0.26.7"
    description={(lang) => <>
        <p>Whether to paginate the table server-side. Defaults to <code>{lang === "js" ? "false" : "False"}</code>.</p>
        <p>Tables with more than 2500 rows will be paginated by default.</p>
    </>}
/>

<Parameter
    name="density"
    required={false}
    type="literal"
    version="0.27.0"
    description={(lang) => <>
        <p>The density of the table rows. Defaults to <code>{lang === "js" ? "standard" : "standard"}</code>.</p>
        <p>Options:</p>
        <ul>
            <li><code>"compact"</code>: 32px row height</li>
            <li><code>"standard"</code>: 40px row height</li>
            <li><code>"comfortable"</code>: 48px row height</li>
        </ul>
    </>}
    idSuffix="2"
/>

<Parameter
    name="overflow"
    required={false}
    type="literal"
    version="0.27.0"
    description={(lang) => <>
        <p>The overflow behavior of the table cells. Defaults to <code>{lang === "js" ? "ellipsis" : "ellipsis"}</code>.</p>
        <p>Options:</p>
        <ul>
            <li><code>"ellipsis"</code>: The content will be truncated with an ellipsis.</li>
            <li><code>"clip"</code>: The content will be clipped to the cell.</li>
            <li><code>"dynamic"</code>: The cell height will grow to fit the content.</li>
        </ul>
    </>}
    idSuffix="2"
/>

<ParameterTemplate.Style />
